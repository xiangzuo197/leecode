#刷面试题记录
2020快手秋招算法A
1.梯度下降法正确的步骤
  a.用随机值初始化权重和偏差
  b.把输入传入网络，得到输出值
  c.计算预测值和真实值之间的误差
  d.对每一个产生误差的神经元，调整相应的（权重）值以减小误差
  e.重复迭代，直至得到网络权重的最佳值
  
2.一个袋子里放着5个红球，6个白球，现在随机从袋子里取两个球，取完之后发现这两个球的颜色相同，问这两个球是红色的概率是多少？
A=两个球颜色相同，B等于两个球都是红色。事件AB种类可以计算，A有C5 2+C6 2=25种情况，B有C5 2=10种情况，P（B|A）=10/25=40%

3.已知char str[20]=“0123456789” ， 则strlen(str) 和 sizeof(str)的结果是？ 
10，20

int a=strlen(str); //a=10; >>>> strlen 计算字符串的长度，以结束符 0x00 为字符串结束。
int b=sizeof(str); //而b=20; >>>> sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。 

trlen是用来计算字符串的长度，遇到第一个NULL('\0')为止，不包括‘\0’。
sizeof是用来计算变量或者对象、类型所占字节的多少。
sizeof是C/C++中的一个运算符（关键字），计算对象或者类型在内存中所占用的字节数。
strlen是C语言中的库函数，计算字符串长度,不包括尾0。
引用头文件#include<stdio.h>。
库函数原型：size_t strlen(const char *s)
注：sizeof是关键字,不是函数。strlen是函数。
例如
char test[20] = “hello”;
char *test1 = “hello!”;
char test2[] = “hello!!”;

strlen(test) //5 strlen计算的是字符串的实际长度，不包括尾0，以第一个’\0’为结束符。
sizeof(test) //20 定义的char型数组，占用了20个字节。
strlen(test1) //6 trlen计算的是字符串的实际长度，不包括尾0，以第一个’\0’为结束符。
sizeof(test1) // 8 计算了指针类型所在的字节数，取决于32/64位机，32位占4字节，64位占8字节。
strlen(test2) //7 strlen计算的是字符串的实际长度，不包括尾0，以第一个’\0’为结束符。
sizeof(test2) // 8 定义的char型数组，占用了8个字节，其中包括了’\0’为结束符。

4.在Logistic Regression中，如果同时加入L1和L2范数，下列描述错误的是（D）
  A. 可以做特征选择,并在一定程度上防止过拟合

  B. 能解决维度灾难问题

  C. 能加快计算速度

  D. 可以获得更准确的结果




L1正则化和L2正则化

正则化项即罚函数，该项对模型向量进行“惩罚”，从而避免单纯最小二乘问题的过拟合问题。训练的目的是最小化目标函数，则C越小，意味着惩罚越小，分类间隔也就越小，分类错误也就越少。

正则化项本质上是一种先验信息，整个最优化问题从贝叶斯观点来看是一种贝叶斯最大后验估计，其中正则化项对应后验估计中的先验信息，损失函数对应后验估计中的似然函数，两者的乘积即对应贝叶斯最大后验估计的形式，如果你将这个贝叶斯最大后验估计的形式取对数，即进行极大似然估计，你就会发现问题立马变成了损失函数+正则化项的最优化问题形式。

(1) 避免出现过拟合（over-fitting）。经验风险最小化 + 正则化项 = 结构风险最小化。

(2) 从模型求解上看，正则化提供了一种唯一解的可能。光用最小二乘拟合可能出现无数组解，加个L1或L2正则化项能有唯一解。

L1范数是指向量中各个元素绝对值之和，用于特征选择; 

L2范数 是指向量各元素的平方和然后求平方根，用于 防止过拟合，提升模型的泛化能力

L1与L2区别：使用L1可以得到稀疏的权值；用L2可以得到平滑的权值


5.下列哪一项能反映出 X 和 Y 之间的强相关性？

A. 相关系数为 0.9

B. 对于无效假设 β=0 的 p 值为 0.0001

C. 对于无效假设 β=0 的 t 值为 30

D. 以上说法都不对

答案：A

解析：相关系数的概念我们很熟悉，它反映了不同变量之间线性相关程度，一般用 r 表示。

其中，Cov(X,Y) 为 X 与 Y 的协方差，Var[X] 为 X 的方差，Var[Y] 为 Y 的方差。r 取值范围在 [-1,1] 之间，r 越大表示相关程度越高。A 选项中，r=0.9 表示 X 和 Y 之间有较强的相关性。

而 p 和 t 的数值大小没有统计意义，只是将其与某一个阈值进行比对,以得到二选一的结论。例如，有两个假设：

    无效假设（null hypothesis）H0：两参量间不存在“线性”相关。

    备择假设（alternative hypothesis）H1：两参量间存在“线性”相关。

如果阈值是 0.05，计算出的 p 值很小，比如为 0.001，则可以说“有非常显著的证据拒绝 H0 假设,相信 H1 假设。即两参量间存在“线性”相关。p 值只用于二值化判断，因此不能说 p=0.06 一定比 p=0.07 更好。


6.“有监督学习会有过拟合的问题，无监督学习没有过拟合的问题” 以上说法是否正确 

错误

7.下列哪一项在神经网络中引入了非线性 （B）
SGD（随机梯度下降）
激活函数
卷积函数
都不正确


修正线性单元是非线性的激活函数

8




8若某算法的计算时间表示为递推关系式：

T(N)=2T(N/2)+NlogN

T(1)=1

则该算法的时间复杂度为()。

o(NlogN)
大O算法，数算内容


9 若某算法的计算时间表示为递推关系式：

T(N)=2T(N/2)+NlogN

T(1)=1

则该算法的时间复杂度为( )。 

主定理

O(N(logN)^2)

https://www.cnblogs.com/oier/p/9454539.html

9.有一个卷积层，其参数如下，
kernel size为3*3*8，kernel个数为16，stride为2，padding为1，
输入特征图尺寸为128*128*8，那么在不考虑偏置的条件下这一层卷积的计算量
（每做一次乘法或加法计算量累积一次）是多少？
（8*9 + 8*9 -1）*64*64*16=9371648

输出尺寸=(输入尺寸-filter尺寸+2*padding）/stride+1=64
宽和高都是这么计算的；

看到stride为1的时候，当kernel为 3 padding为1
或者kernel为5 padding为2 一看就是卷积前后尺寸不变。

11一根木棒，截成三截，组成三角形的概率是多少。

简单的想法：第一锯两种情况，锯中间和不锯中间，各1/2，不能锯中间否则第二刀无论怎么锯都构不成三角形；第二锯可以锯长的亦可以锯短，各1/2，但只能锯长的那一根，否则也构不成三角形，所以是1/4。







在什么情况需要对特征使用归一化处理？
1.归一化可以加快梯度下降法求解最优解的速度。
当特征之间的数值变化范围相差太大时，会使得收敛路径呈Z字型，导致收敛太慢，或者根本收敛不到最优解的结果。
2.归一化可以提高计算精度。
一些分类器需要计算样本之间的距离（如欧氏距离），例如KNN。如果一个特征值域范围非常大，那么距离计算就主要取决于这个特征，从而与实际情况相悖（比如这时实际情况是值域范围小的特征更重要）。
因此，可以看出，当算法需要使用梯度下降的方法求解最优解（比如逻辑回归）或者该算法计算样本点距离时（比如KNN）必须使用归一化处理。
3.神经网络中的输入和输出层（softmax）需归一化，防止爆炸，这里也用到了梯度下降。
归一化的方法有线性归一化，标准差标准化，非线性归一化，最常用的是标准差标准化（standscaler）

13矩阵的广义逆
矩阵A的广义逆为B，则A*B*A=A，B*A*B=B
矩阵不一定存在确定唯一的广义逆 
若矩阵A的广义逆为B，则A*B和B*A都是对称阵。
矩阵A可能不存在广义逆。

14.关于C++11中的std::vector的说法正确的是 


14如图是gdb调试时某个崩溃发生后堆栈的内容。以下说法错误的是 


15某算法的时间复杂度递归公式为
T(n)=1,n=1
T(n)=4T(n/2)+n，n>1

则它的总时间复杂度 

根据主定理，log2 4 = 2 > 1，符合第一种情况，所以复杂度为O（n^log2 4）= O(n^2) 



16若一棵二叉树的前序遍历为a, e, b, d, c，后序遍历为b, c, d, e, a，则根节点的孩子节点为

画出二叉树即可得出只有e是根的孩子节点 

17与数据结构的存储结构无关的术语（D）
循环队列
链表
哈希表
栈

所谓"存储结构无关"是指既可以用数组实现,又可以用链表实现。
栈是逻辑结构 

18数据结构中的线性结构

常用的线性结构有：线性表，栈，队列，双队列，串
关于广义表、数组，是一种非线性的数据结构。
常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树）
线性结构是一个有序数据元素的集合

20、将50个红球和50个白球放到两个盒子中，放法不限，从中抽出一个球，那么抽到的是红球的最大概率是

一个盒子中放入1个红球，另一个盒子放入49个红球和50个白球
概率就是
1/2+1/2 * 49/99=74/99


算法题
求解一元一次方程的正整数解

输入描述：输入一行表示该一元一次方程，其中未知数为X，方程包含加法、减法、乘法。

字符串长度少于20个字符，保证为合法方程。

所有整数绝对值不超过10000000。

输出描述：如果X有唯一正整数解，输出该答案。如果解为非正整数、不存在或解不唯一，输出-1。

示例1：输入 2*X=6  输出 3  示例2： 输入 X+2*X=3*X 输出 -1


import sys
def solve(eq,var='X'):
    #用虚数1j代替X,让eval把X作为数计算，注意一定写1j才能被当成数
    r = eval(eq.replace('=','-(')+')',{var:1j})
    (3259)#计算得到aj+b，由于这个式子我们知道等于0
    #方程的解就是-b/a,也就是-实部/虚部
    res = -1
    if r.imag==0:
        return res
    if int(-r.real%r.imag)==0 and (-r.real//r.imag)>0:
        res = int(-r.real//r.imag)
    return res
  
s = sys.stdin.readline().strip()
res = solve(s)
print(res)
一开始写的只能通过50%，不知道为啥：

	
import sys
def solve(s):
    if not s:
        return -1
    a = s.split('=')
    alll = a[0]+'-'+a[1]
    L = []
    item =[]
    for i in range(len(alll)):
        if alll[i]=='+':
            L.append('+'+str(i))
        if alll[i]=='-':
            L.append('-'+str(i))
                #print(L)
    L.append('+'+str(len(alll)))
        #print(L[-1][-1])
    if s[0]!='-':
        if s[0]=='X':
            item.append('+1*'+alll[:int(L[0][-1])])
        else:   
            item.append('+'+alll[:int(L[0][-1])])
    for i in range(1,len(L)):
        item.append(L[i-1][0]+alll[int(L[i-1][1:])+1:int(L[i][1:])])
    a = 0
    b = 0
    for i in item:
        if 'X' in i:
            a +=int(i[:-2])
        else:
            b+=int(i)
    if a==0:
        res = -1#等于任何数都可以
    else:
        res = -b//a
    return res
          
s = sys.stdin.readline().strip()
res = solve(s)
print(res)

